#! /bin/sh


exit_no_default() {
    echo "Please, set the valid default site name in sites.json" >&2
    exit 1
}

SITES_TEXT="$(cat sites.json | jq -c -r "$(cat sites_to_help_text.jq)")"
[ -z "$(echo "${SITES_TEXT}" | grep ' (default)')" ] && exit_no_default


cat <<'EOF_'
#! /bin/sh


print_help_exit() {
cat <<EOF
Usage: $(basename "$0") [-s SITE] FILE...

Options:
  -s SITE           Specify the site name to upload (default: comfy.moe)
  -u                Output URL
  -f                Output filename only
  -p                Output the same way as the server responses

Supported sites:
EOF_

echo "${SITES_TEXT}"

cat <<'EOF_'
EOF
    exit 0
}

print_usage_exit() {
    echo "Usage: $(basename "$0") [-s SITE] FILE..."
    exit 1
}

get_site_data() {
    local SITE="$1"

    local site_data="$(echo "${SITES_JSON}" | jq -c -r ".sites[\"${SITE}\"]")"
    [ "${site_data}" = null ] && site_data="$(echo "${SITES_JSON}" |
        jq -c -r ".sites[]|select(.aliases)|select(.aliases[]|.==\"${SITE}\")")"

    echo "${site_data}"
}

get_field_value() {
    local FIELDNAME="$1"
    local DEFAULT_VALUE="$2"

    local field_value="$(echo "${SITE_DATA}" | jq -c -r ."${FIELDNAME}")"
    [ -n "${DEFAULT_VALUE}" -a "${field_value}" = null ] && field_value="${DEFAULT_VALUE}"

    echo "${field_value}"
}


SITES_JSON=$(cat <<'EOF'
EOF_

cat sites.json

cat <<'EOF_'
EOF
)


DEFAULT_SITE="$(echo "${SITES_JSON}" | jq -c -r '.default')"
SITE="${DEFAULT_SITE}"
OUTPUT_TYPE="url"

while getopts ':hs:ufp' x; do
    case $x in
        h)
            print_help_exit
            ;;
        s)
            SITE="${OPTARG}"
            ;;
        u)
            OUTPUT_TYPE="url"
            ;;
        f)
            OUTPUT_TYPE="filename"
            ;;
        p)
            OUTPUT_TYPE="preserve"
            ;;
        \?)
            echo "Invalid option: -${OPTARG}" >&2
            print_usage_exit
            ;;
        \:)
            echo "-${OPTARG} needs an argument" >&2
            print_usage_exit
            ;;
    esac
done
shift $((OPTIND-1))

if [ $# -lt 1 ]; then
    print_usage_exit
fi


SITE_DATA="$(get_site_data "${SITE}")"

UPLOAD_URL="$(get_field_value upload)"
DOWNLOAD_URL="$(get_field_value download)"
FILE_FORM_NAME="$(get_field_value file_form_name 'files[]')"
RESPONSE_TEMPLATE="$(get_field_value response '$json:files[].url')"
case "${RESPONSE_TEMPLATE}" in
    '$url')       HANDLE_RESPONSE='(cat; echo) | head -n 1' ;;  # Checking for eol would make code ugly
    '$json:'*)    HANDLE_RESPONSE="jq -c -r $(echo "${RESPONSE_TEMPLATE}" | sed 's/^\$json:/./')" ;;
    *)            echo "Wrong response template value: \"${RESPONSE_TEMPLATE}\"" >&2; exit 1 ;;
esac

ADDITIONAL_FORM_HEADERS="$(echo "${SITE_DATA}" \
    | jq -c -r 'select(.headers)|.headers|to_entries[]|"\(.key)=\(.value)"')"

FORM_HEADERS="$(printf -- "-F '${FILE_FORM_NAME}=@%s' " "$@" | head -c -1)"
[ -n "${ADDITIONAL_FORM_HEADERS}" ] && \
    FORM_HEADERS="${FORM_HEADERS} $(printf -- "-F '%s' " "${ADDITIONAL_FORM_HEADERS}" | head -c -1)"

# Uses single quotes inside ${FORM_HEADERS} to support filenames containing spaces and
# a subshell construct (cmd; cmd) in ${HANDLE_RESPONSE}, so we have to eval it
OUTPUT="$(eval "curl -fsSL ${FORM_HEADERS} '${UPLOAD_URL}' | ${HANDLE_RESPONSE}")"
case "${OUTPUT_TYPE}" in
    url)
        echo "${DOWNLOAD_URL}" | sed "s|\$result|${OUTPUT}|"
        ;;
    filename)
        # Filename must be the last entry in any given URL that points to a file
        echo "${OUTPUT}" | tr '/' '\n' | tail -n 1
        ;;
    preserve)
        echo "${OUTPUT}"
        ;;
esac
EOF_
