#! /bin/sh


exit_no_default() {
    echo "Please, set the valid default site name in sites.json" >&2
    exit 1
}

DEFAULT="$(jq -r .default sites.json)"
SITES_TEXT="$(jq -r "$(cat sites_to_help_text.jq)" sites.json)"
echo "${SITES_TEXT}" | grep -q ' (default)' || exit_no_default


cat <<EOF_
#! /bin/sh


print_help_exit() {
cat <<EOF
Usage: \$(basename "\$0") [-u|-f|-p] [-s SITE] FILE...

Options:
  -s SITE           Specify the site name to upload (default: ${DEFAULT})
  -u                Output URL
  -f                Output filename only
  -p                Output the same way as the server responses

Supported sites:
EOF_

echo "${SITES_TEXT}"

cat <<'EOF_'
EOF
    exit 0
}

print_usage_exit() {
    echo "Usage: $(basename "$0") [-u|-f|-p] [-s SITE] FILE..."
    exit 1
}

get_site_data() {
    _SITE_="$1"

    _site_data_="$(echo "${SITES_JSON}" | jq -r ".sites[\"${_SITE_}\"]")"
    [ "${_site_data_}" = null ] && _site_data_="$(echo "${SITES_JSON}" |
        jq -r ".sites[]|select(.aliases)|select(.aliases[]|.==\"${_SITE_}\")")"

    echo "${_site_data_}"
}

get_field_value() {
    _FIELDNAME_="$1"
    _DEFAULT_VALUE_="$2"

    _field_value_="$(echo "${SITE_DATA}" | jq -r ."${_FIELDNAME_}")"
    ([ -n "${_DEFAULT_VALUE_}" ] && [ "${_field_value_}" = null ]) && _field_value_="${_DEFAULT_VALUE_}"

    echo "${_field_value_}"
}


SITES_JSON=$(cat <<'EOF'
EOF_

cat sites.json

cat <<'EOF_'
EOF
)


DEFAULT_SITE="$(echo "${SITES_JSON}" | jq -r '.default')"
SITE="${DEFAULT_SITE}"
OUTPUT_TYPE="url"

while getopts ':hs:ufp' x; do
    case $x in
        h)
            print_help_exit
            ;;
        s)
            SITE="${OPTARG}"
            ;;
        u)
            OUTPUT_TYPE="url"
            ;;
        f)
            OUTPUT_TYPE="filename"
            ;;
        p)
            OUTPUT_TYPE="preserve"
            ;;
        \?)
            echo -- "Invalid option: -${OPTARG}" >&2
            print_usage_exit
            ;;
        :)
            echo -- "-${OPTARG} needs an argument" >&2
            print_usage_exit
            ;;
    esac
done
shift $((OPTIND-1))

if [ $# -lt 1 ]; then
    print_usage_exit
fi


SITE_DATA="$(get_site_data "${SITE}")"

UPLOAD_URL="$(get_field_value upload)"
DOWNLOAD_URL="$(get_field_value download)"
FILE_FORM_NAME="$(get_field_value file_form_name 'files[]')"
RESPONSE_TEMPLATE="$(get_field_value response "\$json:files[].url")"
case "${RESPONSE_TEMPLATE}" in
    "\$url")       HANDLE_RESPONSE='(cat; echo) | head -n 1' ;;  # Checking for eol would make code ugly
    "\$json:"*)    HANDLE_RESPONSE="jq -r $(echo "${RESPONSE_TEMPLATE}" | sed "s/^\$json:/./")" ;;
    *)             echo "Wrong response template value: \"${RESPONSE_TEMPLATE}\"" >&2; exit 1 ;;
esac

ADDITIONAL_FORM_HEADERS="$(echo "${SITE_DATA}" \
    | jq -r 'select(.headers)|.headers|to_entries[]|"\(.key)=\(.value)"')"

# shellcheck disable=SC2039
FORM_HEADERS="$(printf -- "-F '${FILE_FORM_NAME}=@%s' " "$@" | head -c -1)"
# shellcheck disable=SC2039
[ -n "${ADDITIONAL_FORM_HEADERS}" ] && \
    FORM_HEADERS="${FORM_HEADERS} $(printf -- "-F '%s' " "${ADDITIONAL_FORM_HEADERS}" | head -c -1)"

# Uses single quotes inside ${FORM_HEADERS} to support filenames containing spaces and
# a subshell construct (cmd; cmd) in ${HANDLE_RESPONSE}, so we have to eval it
OUTPUT="$(eval "curl -fsSL ${FORM_HEADERS} '${UPLOAD_URL}' | ${HANDLE_RESPONSE}")"
echo "${OUTPUT}" | while read -r line; do
    case "${OUTPUT_TYPE}" in
        url)
            echo "${DOWNLOAD_URL}" | sed "s|\$result|${line}|"
            ;;
        filename)
            # Filename must be the last entry in any given URL that points to a file
            echo "${line}" | tr '/' '\n' | tail -n 1
            ;;
        preserve)
            echo "${line}"
            ;;
    esac
done
EOF_
